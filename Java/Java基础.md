# Java基础

## 一、对象与类

### 1.1 面对对象基本概念

#### 1.1.1 类

类（class）是构造对象的蓝图或者模板，由类构造（construct）对象的过程成为类的实例化（instance）。

#### 1.1.2 对象

对象的三个主要特征：行为、状态、标识

#### 1.1.3 识别类

在分析问题的过程中寻找名词，方法对应着动词。

#### 1.1.4 类之间的关系

依赖（use-a）、聚合（has-a）、继承（is-a）

依赖：<u>A类的方法</u>操作<u>B类的对象</u>，则A类依赖B类

聚合：B类是A类的组成部分，则A类聚合B类

继承：B类是A类的子类，则A类继承B类

### 1.2 使用内置类

不是所有类都有面向对象的特征，如math类只封装了功能，故不必隐藏和封装数据。

#### 1.2.1 对象与对象变量

要使用对象，就必须构造对象。Java中使用构造器（constructor）构造新实例。构造器是一个特殊的方法，它用来构造并初始化对象。构造器名词需要与类名相同，构造一个对象则new构造器方法.

**对象**与**对象变量**之间存在重大区别：对象变量引用对象后才可以使用对象。

new 操作符返回值是一个引用

对象变量设置为null则表示没有引用任何对象

### 1.3 用户自定义类

简单的类定义形式为：

```java
class ClassName {
  field1;
  field2;
  
  constructor1;
  constructor2;
  
  method1;
  method2;
}
```



一个源文件中只能有一个公共类，且类名必须与文件名一致。（可以有任意数量的非公有类）

#### 1.3.1 构造器

- 构造器与类同名
- 每个类可以有一个以上构造器
- 构造器可以任意个参数
- 构造器没有返回值（无需显示标记）
- 构造器总是伴随new关键字调用

不要在构造器中定义与实力域同名的变量，定义后将会屏蔽同名的实力域，必须使用显示调用实力域才能（this）初始化。

```java
public class TestConstruct {

    private int a;
    private int b;

    public TestConstruct() {
        int a;
        int b;
        a = 10;
        b = 11;
        // 不能初始化实力域中的a，b
    }
  
    public TestConstruct() {
        int a;
        int b;
        this.a = 10;
        this.b = 11;
        // 可以初始化实力域中的a，b
    }

    public int getA() {
        return a;
    }

    public int getB() {
        return b;
    }

    public static void main(String[] args) {
        TestConstruct t = new TestConstruct();
        System.out.println(t.getA());
        System.out.println(t.getB());
    }
}
```

#### 1.3.2 隐式参数与显示参数

对象方法的隐式参数为对象本身，显示参数为方法定义时列出的参数。隐式参数可以通过`this.Name`调用,也可以直接调用。使用this方便区分。

#### 1.3.3 封装的优点

1.改变内部实现，不会影响其他代码（保持返回的内容一致即可）

2.setter可以执行错误检查，直接对域赋值则不会进行处理

不要编写返回引用可变对象的访问器方法，会破坏封装线，返回的引用可以在类外部改变类的状态





## 二、异常捕获

异常捕获要求：

- 向用户通告错误
- 保存所有的操作结果
- 允许用户以适当的形式退出

### 1.处理异常

可能出现的问题或错误：

- 用户输入错误
- 设备错误
- 物理限制
- 代码错误

在Java中，当某个方法不能够正常执行，方法不返还任何值而是抛出（throw）一个封装了错误信息的对象，调用这个方法的代码也将无法执行，异常处理机制将会搜素能够处理这个异常的异常处理器。

#### 异常分类

异常对象都是派生自一个Throwable类，第二层继承为Error和Exception。

Error类描述Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这类错误。

设计Java程序时需要关注Exception类，Exception类下一个继承包括RuntimeException和其他错误。

RuntimeException由程序错误导致的异常。

程序本身没有问题，由于I/O错误这类问题导致的异常属于其他异常。

473页

